# Evasive-Path-Planning
Details an assortment of algorithms which are novel alterations to the well know Dijkstra's method to find the path to a target node which optimally evades a (stationary or moving) surveillor on a grid-based map which can be customized. This problem has many applications in military intelligence and robotics (it was also very fun to work on :) ). The graphics were implemented through Walker M. White's "game2d" package.

The game works as follows, any map is an NxN grid of cells (N is defined by the user). Two of these cells are the start and target cell. Some cells can be initialized to be a possible spot for a surveillor, which assigns an observability score to cells according to a radially decreasing observability function, the evader is trying to avoid the surveillor by minimizing this observability along its path. Some cells are initialized as obstacles, which the evader cannot go through on its path. Obstacles have the advantage of being able to hide certain cells from the surveillor's vision, greatly reducing their observability scores. The implementation of which cells to include in surveillors vision was primarily hand-made, approximating the angle the surveillor's line-of-sight meets the obstacle. This is similar to ray-tracing approaches to line-of-sight.

To run the application, simply download the folder to your computer and run from the correct directory in terminal (python __main__.py). You can edit any of the constants by changing values in consts.py, and you can create maps by initializing a grid according to the specificiation of Grid in models.py. Some maps (notably 3corridors and three_cubes) have been premade in maps.py, and some more simple sample grids are available in Surveillance_Evasion_test.py. You must also specify where the surveillor might be, a probability vector detailing the distribution of those spots, and a stochastic transition matrix detailing how it will move between those spots. This is done in accordance with the Surveillor specification in Surveillance_Evasion.py

These algorithms deal with evasion under certain information states. The first in which the evader knows possible spots the observer could be in, and an apriori probability distribution attached to those spots (which can be found when pressing 'q' after running the main application). The evader seeks to find a path which minimizes the expected cumulative observability over these possible spots.

The next information state has full knowledge of where the surveillor will move over the course of the game. This algorithm does not yield a globally optimal solution as when the surveillor moves the graph's edges change weight, making this a dynamic shortest path problem which is still an open research problem. I get around this by re-calculating a shortest path everytime the surveillor moves from its current position. Understandably, this yields pretty bad worst case complexity, and can lead to backtracking in some cases. A future direction would be implementing algorithms for dynamic graphs such as D* or LPA*, or implementing a "lookahead" distance in which the paths could compensate for future movements better.

The final information state is a mix of the first and second. It has some idea of where the surveillor will be initially and some idea of how it will move from there.  This is achieved by assuming a surveillor's movement is a Markov process over finite state space, and can be defined using a stochastic transition matrix. Since this is still a dynamic shortest path problem, we use heuristic approaches. Notably this algorithm differs from the previous too because it uses realizations to update its probabilistic belief. For example, if along a shortest path, the evader realizes a possible spot the surveillor could be in does not contain the surveillor, it updates the current probability distribution to account for that (using laws of conditional probability). It then recalculates the shortest path up until it can observe where the surveillor is. Additionally, if it observes that a surveillor is in a spot, it updates its probability distribution and constructs a shortest path for the expected number of steps it will take for the surveillor to leave that spot (which is a Geometric random variable). Again, this could have to recalculate the shortest path many times, so is not that efficient. It also might be too big of an assumption to assume the surveillor's motion is Markovian, as path-dependency could play a role in deciding where the surveillor goes to next in a real-world context. This algorithm has the advantage of being realistic in that it updates under new information, as opposed to the first two which are pre-planned.

An interesting direction to look at in the future will be to have a surveillor's path that is also dynamic, as in it is trying to maximize the observability along the evader's path. This would resemble the well studied Surveillance Evasion Game and possible min-max approaches could be used to find the Nash Equilibrium paths. 
